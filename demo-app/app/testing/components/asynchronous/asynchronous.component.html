<div>
    <h1>Angular Testing - Asynchronous Operations</h1>
    <hr />

    <h2>1. Angular Testing Utility - async/fixture.whenStable()</h2>
    <p>a. Will return a promise when the asynchronous operations are done and the fixture is stable.</p>
    <p>b. Assert inside the callback block.</p>
    <mat-card class='code-block-card'>
        <pre>
            <code class="code-block line">
<span class="keyword">it</span>(<span class="string">'should set endDate html element'</span>, <span class="keyword">async</span> (() => {{ '{' }}
    <span class="keyword">let</span> de = fixture.debugElement.query(By.css('#end-date-input'));
    <span class="keyword">let</span> ne: HTMLInputElement = de.nativeElement;

    component.endDate = <span class="string">'2019-12-12'</span>;
    fixture.detectChanges();

    fixture.whenStable().<span class="keyword">then</span>(() => {{ '{' }}
        expect(ne.value).toEqual(component.endDate);
    });
}));
            </code>
        </pre>
    </mat-card>

    <h2>2. Angular Testing Utility - fakeAsync/tick()</h2>
    <p>a. tick() method will execute any asynchronous tasks in the microtask queue.</p>
    <p>b. tick(100) would execute any asynchronous tasks that would occur within 100ms.</p>
    <mat-card class='code-block-card'>
        <pre>
            <code class="code-block line">
<span class="keyword">it</span>(<span class="string">'should set endDate html element'</span>, <span class="keyword">fakeAsync</span> (() => {{ '{' }}
    <span class="keyword">let</span> de = fixture.debugElement.query(<span class="keyword">By</span>.css(<span class="string">'#end-date-input'</span>));
    <span class="keyword">let</span> ne: HTMLInputElement = de.nativeElement;

    component.endDate = <span class="string">'2019-12-12'</span>;
    fixture.detectChanges();
    tick();

    expect(ne.value).toEqual(component.endDate);
}));
            </code>
        </pre>
    </mat-card>

    <h2>3. Angular Testing Utility - fakeAsync/flush()</h2>
    <p>a. flush() method will execute any asynchronous tasks in the macrotask queue.</p>
    <p>b. flushMicrotasks() is synonymous with tick().</p>

    <mat-card class='code-block-card'>
        <pre>
            <code class="code-block line">
<span class="keyword">it</span>(<span class="string">'should return the edited unit data'</span>, <span class="keyword">fakeAsync</span>,(() => {{ '{' }}
    <span class="keyword">let</span> data = {{ '{' }}};
    <span class="keyword">let</span> dialogRef = <span class="keyword">this</span>.dialog.open(Component, {{ '{' }}data: data});
    <span class="keyword">let</span> spy = jest.fn();
    <span class="keyword">let</span> returnData = {{ '{' }}
        data: data
    };
    dialogRef.afterClosed().subscribe(spy);

    dialogRef.close(returnData);
    fixture.detectChanges();
    flush();

    expect(spy).toHaveBeenCalledWith(returnData);
}));
            </code>
        </pre>
    </mat-card>

    <h2>4. ES8 Async Functions</h2>
    <p>a. Built on top of Promises.</p>
    <p>b. Await works with Promises, not callbacks.</p>

    <mat-card class='code-block-card'>
        <pre>
            <code class="code-block line">
it(<span class="string">'should set endDate html element'</span>, <span class="keyword">async</span> () => {{ '{' }}
    <span class="keyword">let</span> de = fixture.debugElement.query(By.css(<span class="string">'#end-date-input'</span>));
    <span class="keyword">let</span> ne: HTMLInputElement = de.nativeElement;

    component.endDate = <span class="string">'20190-12-12'</span>;
    <span class="keyword">await</span> fixture.detectChanges();

    expect(ne.value).toEqual(component.endDate);
});
            </code>
        </pre>
    </mat-card>
</div>